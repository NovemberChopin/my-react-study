{
  "success": true,
  "data": [
    {
      "id": "5c2edce13898674067a7b103",
      "author_id": "5372465f3c72496d41009adc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src=\"//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej\" alt=\"image.png\"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a>\n<img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>",
      "title": "送几本《Node.js开发实战》",
      "last_reply_at": "2019-02-13T09:54:13.317Z",
      "good": false,
      "top": true,
      "reply_count": 319,
      "visit_count": 8132,
      "create_at": "2019-01-04T04:11:13.570Z",
      "author": {
        "loginname": "meikidd",
        "avatar_url": "https://avatars0.githubusercontent.com/u/376338?v=4&s=120"
      }
    },
    {
      "id": "5bd4772a14e994202cd5bdb7",
      "author_id": "504c28a2e2b845157708cb61",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>",
      "title": "服务器迁移至 aws 日本机房",
      "last_reply_at": "2019-02-12T07:24:19.605Z",
      "good": false,
      "top": true,
      "reply_count": 122,
      "visit_count": 13791,
      "create_at": "2018-10-27T14:33:14.694Z",
      "author": {
        "loginname": "alsotang",
        "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
      }
    },
    {
      "id": "5c1760337ec239239ff579a2",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>北京1月12日Node Party活动视频地址：<a href=\"https://edu.talkingdata.com/open-class\">https://edu.talkingdata.com/open-class</a></p>\n<p>Node Party 是社区发起的一个面向 Node.js 和大前端爱好者的非商业，社区驱动的技术分享聚会，希望能够构建一个持续的分享学习平台，一起发展大前端生态。</p>\n<p>北京1月12日Node Party线下活动（周六）下午2点到6点，将近100人</p>\n<ul>\n<li>主题分享（已确认，共5个主题：3个Node.js主题，一个运维，一个前端）\n<ul>\n<li>《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）</li>\n<li>《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）</li>\n<li>《浅谈nodejs异步那点事》（360）</li>\n<li>结合Node.js讲一下Docker 实践和原理（网易）</li>\n<li>iview作者：如何做好一个开源项目（TalkingData）</li>\n</ul>\n</li>\n<li>视情况可以考虑晚上AA聚</li>\n</ul>\n<p>时间：北京1月12日（周六）下午2点到6点\n地点：东直门TalkingData赞助的502教室\n人数：最多100人\n直播地址：<a href=\"https://live.bilibili.com/1353202\">https://live.bilibili.com/1353202</a></p>\n<p>现场还有 <a href=\"/user/justjavac\">@justjavac</a>，@小爵，@快手天翔 @王龑 等大咖。</p>\n<p>图灵出版社赞助了20本书，现场送给大家</p>\n<h2>日程安排</h2>\n<p>每个主题分享+答疑共45分钟，5个主题分享：3个Node.js主题，一个运维，一个前端\n茶歇5分钟（北京乐至道科技有限公司赞助茶歇，已经京东到会场）\n圆桌会议30分钟</p>\n<p>2:00-2:45\n刘露颖：《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）</p>\n<p>2:45-3:30\n张晋涛：《结合Node.js讲一下Docker 实践和原理》（网易）</p>\n<p>3:30-4:15\niView作者Aresn：如何做好一个开源项目（TalkingData）</p>\n<p>茶歇5分钟，感谢北京乐至道科技有限公司。DaDEX.io基于EOS公链开发，链上合约自动执行，全部交易上链，率先实现去中心化交易、高并发、低手续费、资金安全、最高交易透明的真去中心化交易所范式，无需注册、认证等繁琐流程，个人钱包内一键交易。致力于完善EOS生态，服务EOS用户，与跨链技术的结合，向传统中心化交易所发起挑战</p>\n<p>4:20-4:50\n圆桌会议：畅想一下前端2019（大神待定）</p>\n<p>4:50-5:35\n兴百放：《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）</p>\n<p>5:35-6:10\n宋光宇：《浅谈nodejs异步那点事》（360）</p>\n<h2>主题</h2>\n<h3>1）《重新认识Node.js后端开发》</h3>\n<p>兴百放，先就职在美团外卖事业部，负责前后端分离，以及 Nodejs 推广工作。本着不管黑猫白猫，只要能解决现实业务问题，提高团队工作效率，就是好猫的原则，致力于让团队成员从重复，耗时，繁琐的一些工作中解放出来。</p>\n<p>随着前端行业的蓬勃发展，越来越多的技术团队，对前端的职责范围，也慢慢的延伸到后端。这里就分享一些在我们进行服务自治（BFF），以及接管传统后端职责一些沉淀和经验。内容主要包括如何做技术框架的选型，使用 egg 一些经验总结，和 eggjs + React + SSR 做同构直出等内容 。</p>\n<p><img src=\"//static.cnodejs.org/FnS8WR95lO1Ff7KevyeHsDHuNCjp\" alt=\"兴百放.png\"></p>\n<h3>2）《Docker 实践和原理》</h3>\n<p>张晋涛，目前任网易有道资深运维开发工程师, 负责 DevOPS 实践落地及 Kubernetes 容器化平台及自动化平台的规划建设等。骨灰级 Linux/Vim 玩家，对 Docker， Kubernetes 及相关生态有大量实践及深入源码的研究。曾负责美图运维自动化平台体系建设。掘金小册《Kubernetes 从上手到实践》作者。</p>\n<p>随着 Kubernetes 等云原生技术的事实标准已经形成，容器化技术作为其重要的组成部分也被使用的越来越广泛。在我们的开发实践中，如何更好的利用容器化技术( Docker )来提升我们的开发，测试效率也是我们所关注的重点。 本次分享集中于如何用 Docker 提升我们的效率以及如何用好它。以 node 和 前端为入手点，希望能对大家有所帮助。</p>\n<p><img src=\"//static.cnodejs.org/FoVKIjHzQJqhwe6IgBWiw2BEWoX-\" alt=\"张晋涛.png\"></p>\n<h3>3）《浅谈Node.js异步那点事》</h3>\n<p>宋光宇 360前端工程师 360视频云/360云盘@奇舞团，</p>\n<p>nodejs给前端赋予了更多的生命力，它的异步模型给他带来无限的潜力。\n今天通过libuv这个nodejs核心库来聊聊nodejs异步的那点事。</p>\n<p><img src=\"//static.cnodejs.org/FmlpCMQIdEjJBXaxDSLS77gpcdqw\" alt=\"宋光宇.png\"></p>\n<h3>4）iView作者：如何做好一个开源项目</h3>\n<p>Aresn，基于 Vue.js 的开源 UI 组件库 — iView 的作者。现担任大数据公司 TalkingData 前端架构师。著有《Vue.js实战》、《Vue.js组件精讲》。\nTopic：</p>\n<ul>\n<li>iView 的故事</li>\n<li>第一批用户</li>\n<li>持续运营</li>\n<li>国际化</li>\n<li>让更多的人参与</li>\n<li>让 Robot 来做“坏人”</li>\n<li>赞助与商业化</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FlPAOO-2v0z85GbQ5StQPcIo5ESN\" alt=\"梁灏.png\"></p>\n<h3>5）《用mqtt协议实现Node.js长连接服务》</h3>\n<p>刘露颖，曾就职搜狐视频，新浪博客，目前任职新浪移动团队资深前端开发工程师，负责nodejs相关的服务开发与维护、以及部分运维相关工作。致力于v8的研究，对c++与nodejs之间的关系有深厚兴趣，并付诸实践。</p>\n<p>mqtt协议随着各种手机app的普及，在移动互联网中有了广泛的应用，借着项目的实践过程，讲术如何更好的使mqtt与nodejs相结合，为现在越来越普遍的高并发场景提供长连接服务的解决方案。</p>\n<p><img src=\"//static.cnodejs.org/FtVeXBznM2mqBtcxdDQEiC13R_xj\" alt=\"刘露颖.png\"></p>\n<h2>微信群</h2>\n<p>群满100人后无法加群的, 添加我微信 mcdongWang 备注 node party 北京 我回拉你进群</p>\n<p><img src=\"//static.cnodejs.org/FvqZCML0PfbFHt6xknAhJmkWKDPU\" alt=\"31545188678_.pic.jpg\"></p>\n<p>公众号文章地址</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&amp;mid=2661157727&amp;idx=1&amp;sn=0b7a6aa495fbe3afe4a4d3774faf8706&amp;chksm=80d5d68bb7a25f9d125e17ff08d1f373435db4a8a7fe2d074f4fbe58c517beb93266e08a4295&amp;token=1373872492&amp;lang=zh_CN#rd\">https://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&amp;mid=2661157727&amp;idx=1&amp;sn=0b7a6aa495fbe3afe4a4d3774faf8706&amp;chksm=80d5d68bb7a25f9d125e17ff08d1f373435db4a8a7fe2d074f4fbe58c517beb93266e08a4295&amp;token=1373872492&amp;lang=zh_CN#rd</a></p>\n</div>",
      "title": "【\b活动+视频】北京1月12日Node Party活动",
      "last_reply_at": "2019-01-28T04:35:22.027Z",
      "good": false,
      "top": true,
      "reply_count": 46,
      "visit_count": 6595,
      "create_at": "2018-12-17T08:37:07.278Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
      }
    },
    {
      "id": "5c62262f05cc322e7b137ec9",
      "author_id": "59e6c301bcfcc03162f2ffc3",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var o={} \ni=0\no.valueOf=function(){\n return i++\n}\no==0\n&#x2F;&#x2F;true\no==0\n&#x2F;&#x2F;false\n</code></pre><p>今天真的就遇到该系列了… 由于get set 导致两次取值不一致的情况…</p>\n</div>",
      "title": "哇你居然在代码里面下毒系列--1",
      "last_reply_at": "2019-02-13T11:02:45.964Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 482,
      "create_at": "2019-02-12T01:49:35.274Z",
      "author": {
        "loginname": "spitWind",
        "avatar_url": "https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"
      }
    },
    {
      "id": "5c63f8cd0752e020af9433d4",
      "author_id": "59e6c301bcfcc03162f2ffc3",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>Efilemangage</p>\n<p><a href=\"https://github.com/spitWind/EFileMangage\">文件管理器</a></p>\n<p>##启动</p>\n<pre class=\"prettyprint language-bash\"><code>npm instal l\nelectron .\n</code></pre><p>##功能\n1.初始一个文件收藏夹 以及备注功能\n欢迎fork\n##授权\n禁止任意形式所有商业行为,以及传递后的商业行为</p>\n</div>",
      "title": "Efilemangage 欢迎加入~",
      "last_reply_at": "2019-02-13T11:00:29.773Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 44,
      "create_at": "2019-02-13T11:00:29.773Z",
      "author": {
        "loginname": "spitWind",
        "avatar_url": "https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"
      }
    },
    {
      "id": "5c63f0c70752e020af943395",
      "author_id": "56ce68bc842c03521a73520e",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如题，代码执行后报错：a is not defined\n顺带研究下var和let的区别：var a=1;function foo (){console.log(‘a:’,a);var a = 2;};foo();为什么是打印a:undefined</p>\n</div>",
      "title": "let a=1;function foo (){console.log('a:',a);let a = 2;};foo();为什么报错？",
      "last_reply_at": "2019-02-13T10:37:24.055Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 51,
      "create_at": "2019-02-13T10:26:15.926Z",
      "author": {
        "loginname": "JarvisQJ",
        "avatar_url": "https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"
      }
    },
    {
      "id": "5c62aef20752e020af942e41",
      "author_id": "5ba0f14737a6965f59051ab5",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://docsmall.com\">docsmall在线图片压缩工具</a></p>\n<p>有需要的朋友可以用用看</p>\n<p><img src=\"//static.cnodejs.org/FrbnjzNz3fFX1IvNNSZdiDYH4QBD\" alt=\"20190212193207.gif\"></p>\n</div>",
      "title": "我们开发了一个在线图片压缩、PDF 压缩、合并、分割的小工具",
      "last_reply_at": "2019-02-13T10:12:42.584Z",
      "good": false,
      "top": false,
      "reply_count": 8,
      "visit_count": 321,
      "create_at": "2019-02-12T11:33:06.418Z",
      "author": {
        "loginname": "houxiaohou",
        "avatar_url": "https://avatars0.githubusercontent.com/u/1525931?v=4&s=120"
      }
    },
    {
      "id": "5c60b47705cc322e7b137b3a",
      "author_id": "5ae04357a86ec1f308ec251f",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如何制作前端直接操作服务器数据的sdk? 就像微信小程序的云开发，前端操作数据库的API与后端操作数据库的API一样。</p>\n</div>",
      "title": "如何制作前端直接操作服务器数据的sdk?",
      "last_reply_at": "2019-02-13T09:19:56.457Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 303,
      "create_at": "2019-02-10T23:32:07.103Z",
      "author": {
        "loginname": "yuquanH",
        "avatar_url": "https://avatars1.githubusercontent.com/u/27963145?v=4&s=120"
      }
    },
    {
      "id": "5c63dc4a0752e020af943300",
      "author_id": "5bf517a1e6481c5709f5de14",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><h5>代码</h5>\n<pre class=\"prettyprint\"><code>const group = await Cabinet.findAll({\n        include: [tagsInfo],\n        where: opt,\n        attributes: [&quot;groupName&quot;, &quot;type&quot;],\n        group: [&quot;groupName&quot;, &quot;type&quot;],\n        logging: console.log,\n});\n</code></pre><h5>生成的查询语句</h5>\n<p>SELECT “Cabinet”.“id”, “Cabinet”.“groupName”, “Cabinet”.“type”, “tags”.“id” AS “<a href=\"http://tags.id\">tags.id</a>”, “tags”.“name” AS “<a href=\"http://tags.name\">tags.name</a>”, “tags”.“type” AS “tags.type”, “tags”.“pid” AS “tags.pid”, “tags-&gt;cabinet_tags_map”.“createdAt” AS “tags.cabinet_tags_map.createdAt”, “tags-&gt;cabinet_tags_map”.“updatedAt” AS “tags.cabinet_tags_map.updatedAt”, “tags-&gt;cabinet_tags_map”.“TagId” AS “tags.cabinet_tags_map.TagId”, “tags-&gt;cabinet_tags_map”.“CabinetId” AS “tags.cabinet_tags_map.CabinetId” FROM “cabinet_cabinet” AS “Cabinet” LEFT OUTER JOIN ( “cabinet_tags_map” AS “tags-&gt;cabinet_tags_map” INNER JOIN “cabinet_tags” AS “tags” ON “tags”.“id” = “tags-&gt;cabinet_tags_map”.“TagId”) ON “Cabinet”.“id” = “tags-&gt;cabinet_tags_map”.“CabinetId” AND (“tags”.“deletedAt” &gt; ‘2019-02-13 16:33:33.971 +08:00’ OR “tags”.“deletedAt” IS NULL) WHERE (“Cabinet”.“deletedAt” &gt; ‘2019-02-13 16:33:33.971 +08:00’ OR “Cabinet”.“deletedAt” IS NULL) GROUP BY “groupName”, “type”;</p>\n<h5>问题</h5>\n<pre class=\"prettyprint\"><code>查询语句第一行中的select中 除了我需要查询的字段  groupName ,  type  之外多出了很多无用的字段，这些导致报错\n</code></pre><p><code>column &quot;Cabinet.id&quot; must appear in the GROUP BY clause or be used in an aggregate function</code>\n\t这有没有办法去除？\n\t如果可以的话希望大佬们能更改下代码，我去研究研究</p>\n</div>",
      "title": "sequelize 使用 find&findAll查询时，能否去除多余查询的列？",
      "last_reply_at": "2019-02-13T08:58:50.784Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 65,
      "create_at": "2019-02-13T08:58:50.784Z",
      "author": {
        "loginname": "91hanbao",
        "avatar_url": "https://avatars0.githubusercontent.com/u/15627199?v=4&s=120"
      }
    },
    {
      "id": "5c50213fa4647e02328f21f8",
      "author_id": "57bbcb58b32043f532d40e6f",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近想学个 node 框架（支持 ts），发现这仨框架应该算是比较流行的了（express 略古老，koajs 还要自己拼装插件）。</p>\n<p>不知道这三个框架哪一个比较合适？</p>\n<p>打算的架构是 nodejs + redis + mongodb/mysql。</p>\n</div>",
      "title": "Egg.js/thinkjs/nestjs 该如何选择？",
      "last_reply_at": "2019-02-13T08:30:02.922Z",
      "good": false,
      "top": false,
      "reply_count": 32,
      "visit_count": 1428,
      "create_at": "2019-01-29T09:47:43.325Z",
      "author": {
        "loginname": "JZLeung",
        "avatar_url": "https://avatars2.githubusercontent.com/u/7995232?v=4&s=120"
      }
    },
    {
      "id": "5c203e7776c4964062a1ce04",
      "author_id": "5129b03cdf9e9fcc58f3673c",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>各位小哥哥小姐姐，分享个圣诞桌面祝大家圣诞快乐\n<a href=\"http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3\">http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3</a>\n<img src=\"//static.cnodejs.org/FrFmzitH9OluHpCz3xAZlMPwHjww\" alt=\"QQ截图20181224103521.jpg\"></p>\n</div>",
      "title": "圣诞桌面 Merry Christmas",
      "last_reply_at": "2019-02-13T08:02:38.954Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 660,
      "create_at": "2018-12-24T02:03:35.105Z",
      "author": {
        "loginname": "yunfei",
        "avatar_url": "https://avatars1.githubusercontent.com/u/6891001?v=4&s=120"
      }
    },
    {
      "id": "5b5e78f5673571454c633cea",
      "author_id": "5b56866ae740336c7bedb345",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>",
      "title": "Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程",
      "last_reply_at": "2019-02-13T06:50:52.267Z",
      "good": false,
      "top": false,
      "reply_count": 62,
      "visit_count": 12874,
      "create_at": "2018-07-30T02:33:25.113Z",
      "author": {
        "loginname": "songsunli",
        "avatar_url": "https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"
      }
    },
    {
      "id": "5c59166605cc322e7b13751b",
      "author_id": "5276bef8d2b3893f2a1943fb",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://gridsome.org\">https://gridsome.org</a>\n各位有人用过这个吗？今天看到个 Gridsome 用起来十分舒服，基本上等同于 Vue 里的 Gatsby，因为 Vue 的单文件组件机制，看起来比 JS、HTML、React 混成一坨的 React 代码更优雅点，用法跟 Nuxt 其实很像，也提供了 Nuxt 里没有的东西，静态化应该做的比 Nuxt 更好，已经极致优化过速度，自动代码分包和其他一系列懒加载、生成静态配套，连图片的懒加载都做了。</p>\n<p>而且还集成了 GraphQL，在单文件组件里就可以直接用 &lt;page-query&gt; 的这个类似 &lt;script&gt; 的标签来直接调用 GraphQL，觉得比那种写在代码里的优雅也省事多了，对性能、SEO和开发效率都有优化，不过看国内好像还没什么人用啊？</p>\n</div>",
      "title": "Gridsome - Vue.js 生态圈下的 Gatsby.js",
      "last_reply_at": "2019-02-13T04:12:16.816Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 495,
      "create_at": "2019-02-05T04:51:50.988Z",
      "author": {
        "loginname": "andyhu",
        "avatar_url": "https://avatars3.githubusercontent.com/u/203980?v=4&s=120"
      }
    },
    {
      "id": "5c60e10605cc322e7b137bef",
      "author_id": "58d140302c8bf2a836456213",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>摘要：</strong> 理解JS继承。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000016542417\">搞懂 JavaScript 继承原理</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>在理解继承之前，需要知道 js 的三个东西：</p>\n<ul>\n<li>\n<ol>\n<li>什么是 JS 原型链</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>this 的值到底是什么</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>JS 的 new 到底是干什么的</li>\n</ol>\n</li>\n</ul>\n<h3>1. 什么是 JS 原型链？</h3>\n<p>我们知道 JS 有对象，比如</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = { name: &quot;obj&quot; };\n</code></pre><p>我们通过控制台把 obj 打印出来：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-01.png\" alt></p>\n<p>我们会发现 obj 已经有几个属性（方法）了。<strong>那么问题来了：valueOf / toString / constructor 是怎么来？我们并没有给 obj.valueOf 赋值呀。</strong></p>\n<p>上面这个图有点难懂，我手画一个示意图：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-02.png\" alt></p>\n<p>我们发现控制台打出来的结果是：</p>\n<ul>\n<li>obj 本身有一个属性 name (这是我们给它加的)</li>\n<li>obj 还有一个属性叫做 <strong>proto</strong>(它是一个对象)</li>\n<li>obj 还有一个属性，包括 valueOf, toString, constructor 等</li>\n<li>obj.<strong>proto</strong>其实也有一个叫做<strong>proto</strong>的属性(console.log 没有显示)，值为 null</li>\n</ul>\n<p>现在回到我们的问题：obj 为什么会拥有 valueOf / toString / constructor 这几个属性？</p>\n<p><strong>答案： 这跟 <strong>proto</strong>有关 。</strong></p>\n<p>当我们「读取」 obj.toString 时，JS 引擎会做下面的事情：</p>\n<ul>\n<li>看看 obj 对象本身有没有 toString 属性。没有就走到下一步。</li>\n<li>看看 obj.<strong>proto</strong> 对象有没有 toString 属性， 发现 obj.<strong>proto</strong> 有 toString 属性， 于是找到了，所以 obj.toString 实际就是第 2 步中找到的 obj.<strong>proto</strong>.toString。</li>\n<li>如果 obj.<strong>proto</strong>没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong></li>\n<li>如果 obj.<strong>proto</strong>.<strong>proto</strong>也没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong></li>\n<li>直到找到 toString 或者 <strong>proto</strong> 为 null。</li>\n</ul>\n<p>上面的过程，就是「读」属性的「搜索过程」。而这个「搜索过程」，是连着由 <strong>proto</strong> 组成的链子一直走的。<strong>这个链子，就叫做「原型链」。</strong></p>\n<h4>共享原型链</h4>\n<p>现在我们还有另一个对象</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj2 = { name: &quot;obj2&quot; };\n</code></pre><p>如图:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-03.png\" alt></p>\n<p>那么 obj.toString 和 obj2.toString 其实是同一东西， 也就是 obj2.<strong>proto</strong>.toString。</p>\n<p>说白了，我们改其中的一个 <strong>proto</strong>.toString ，那么另外一个其实也会变!</p>\n<h4>差异化</h4>\n<p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？\n直接赋值就好了：</p>\n<pre class=\"prettyprint language-javascript\"><code>obj.toString = function() {\n    return &quot;新的 toString 方法&quot;;\n};\n</code></pre><p><img src=\"https://image.fundebug.com/2019-02-10-04.png\" alt></p>\n<p><strong>小结</strong></p>\n<ul>\n<li>[读]属性时会沿着原型链搜索</li>\n<li>[新增]属性时不会去看原型链</li>\n</ul>\n<h3>2. this 的值到底是什么</h3>\n<p>你可能遇到过这样的 JS 面试题：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 打印出的 this 是 obj\nbar(); &#x2F;&#x2F; 打印出的 this 是 window\n</code></pre><p>请解释最后两行函数的值为什么不一样。</p>\n<h4>函数调用</h4>\n<p>JS（ES5）里面有三种函数调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func(p1, p2);\nobj.child.method(p1, p2);\nfunc.call(context, p1, p2); &#x2F;&#x2F; 先不讲 apply\n</code></pre><p>一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。\n我们方方老师大姥说了，你一定要记住，第三种调用形式，才是正常调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p>其他两种都是语法糖，可以等价地变为 call 形式：</p>\n<p>func(p1, p2)等价于 func.call(undefined, p1, p2);</p>\n<p>obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);</p>\n<p>至此我们的函数调用只有一种形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p><strong>这样，this 就好解释了</strong> this 就是上面 context。</p>\n<p>this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。</p>\n<p>先看 func(p1, p2) 中的 this 如何确定：</p>\n<pre class=\"prettyprint language-javascript\"><code>当你写下面代码时;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc();\n等价于;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc.call(undefined); &#x2F;&#x2F; 可以简写为 func.call()\n</code></pre><p>按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：</p>\n<blockquote>\n<p>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p>\n</blockquote>\n<p>因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(obj); &#x2F;&#x2F; 那么里面的 this 就是 obj 对象了\n</code></pre><p>回到题目：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 转换为 obj.foo.call(obj)，this 就是 obj\nbar();\n&#x2F;&#x2F; 转换为 bar.call()\n&#x2F;&#x2F; 由于没有传 context\n&#x2F;&#x2F; 所以 this 就是 undefined\n&#x2F;&#x2F; 最后浏览器给你一个默认的 this —— window 对象\n</code></pre><h4>[ ] 语法</h4>\n<pre class=\"prettyprint language-javascript\"><code>function fn() {\n    console.log(this);\n}\nvar arr = [fn, fn2];\narr[0](); &#x2F;&#x2F; 这里面的 this 又是什么呢？\n</code></pre><p>我们可以把 arr<a href=\"https://segmentfault.com/a/1190000016542417#\">0</a> 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr[0]();\n</code></pre><p>假想为 arr.0()\n然后转换为 arr.0.call(arr)\n那么里面的 this 就是 arr 了 :)</p>\n<p><strong>小结：</strong></p>\n<ul>\n<li>this 就是你 call 一个函数时，传入的第一个参数。</li>\n<li>如果你的函数调用不是 call 形式， 请将其转换为 call 形式</li>\n</ul>\n<p><strong>码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>3. JS 的 new 到底是干什么的？</h3>\n<p>我们声明一个士兵，具有如下属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵 = {\n    ID: 1, &#x2F;&#x2F; 用于区分每个士兵\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    生命值: 42,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><p>我们制造一个士兵， 只需要这样：</p>\n<pre class=\"prettyprint language-javascript\"><code>兵营.制造(士兵);\n</code></pre><p>如果需要制造 100 个士兵怎么办呢？</p>\n<pre class=\"prettyprint language-javascript\"><code>循环 100 次吧：\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    兵种:&quot;美国大兵&quot;,\n    攻击力:5,\n    生命值:42,\n    行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n    奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n    死亡:function(){ &#x2F;*Go die*&#x2F;    },\n    攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n    防御:function(){ &#x2F;*护脸*&#x2F;       }\n  }\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>哎呀，看起来好简单</p>\n<h4>质疑</h4>\n<p>上面的代码存在一个问题：浪费了很多内存</p>\n<ul>\n<li>行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100 个奔跑……</li>\n<li>这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。</li>\n<li>只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。</li>\n</ul>\n<h4>改进</h4>\n<p>通过第一节可以知道 ，我们可以通过原型链来解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 <strong>proto</strong> 指向「士兵原型」。</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    生命值:42\n  }\n\n  &#x2F;*实际工作中不要这样写，因为 __proto__ 不是标准属性*&#x2F;\n  士兵.__proto__ = 士兵原型\n\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><h4>优雅？</h4>\n<p>有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：</p>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  var 临时对象 = {};\n  临时对象.__proto__ = 士兵.原型;\n  临时对象.ID = ID;\n  临时对象.生命值 = 42;\n\n  return 临时对象;\n}\n\n士兵.原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n\n 然后就可以愉快地引用「士兵」来创建士兵了：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>JS 之父看到大家都这么搞，觉得何必呢，我给你们个糖吃，于是 JS 之父创建了 new 关键字，可以让我们少写几行代码：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-05.png\" alt></p>\n<p><strong>只要你在士兵前面使用 new 关键字，那么可以少做四件事情：</strong></p>\n<ol>\n<li>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；</li>\n<li>不用绑定原型，因为 new 会帮你做(new 为了知道原型在哪，所以指定原型的名字 prototype);</li>\n<li>不用 return 临时对象，因为 new 会帮你做；</li>\n<li>不要给原型想名字了，因为 new 指定名字为 prototype。</li>\n</ol>\n<h4>这一次用 new 来写</h4>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  this.ID = ID\n  this.生命值 = 42\n}\n\n士兵.prototype = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;},\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n然后是创建士兵（加了一个 new 关键字）：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(new 士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p><strong>new 的作用，就是省那么几行代码。（也就是所谓的语法糖）</strong></p>\n<h4>注意 constructor 属性</h4>\n<p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵\n};\n</code></pre><p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype.兵种 = &quot;美国大兵&quot;;\n士兵.prototype.攻击力 = 5;\n士兵.prototype.行走 = function() {\n    &#x2F;*走俩步的代码*&#x2F;\n};\n士兵.prototype.奔跑 = function() {\n    &#x2F;*狂奔的代码*&#x2F;\n};\n士兵.prototype.死亡 = function() {\n    &#x2F;*Go die*&#x2F;\n};\n士兵.prototype.攻击 = function() {\n    &#x2F;*糊他熊脸*&#x2F;\n};\n士兵.prototype.防御 = function() {\n    &#x2F;*护脸*&#x2F;\n};\n</code></pre><p>或者你也可以自己给 constructor 重新赋值：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵,\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><h3>四、继承</h3>\n<p><strong>继承的本质就是上面的讲的原型链</strong></p>\n<h4>1)借助构造函数实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent1() {\n    this.name = &quot;parent1&quot;;\n}\n\nParent1.prototype.say = function() {};\n\nfunction Child1() {\n    Parent1.call(this);\n    this.type = &quot;child&quot;;\n}\n\nconsole.log(new Child1());\n</code></pre><p>打印结果：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-06.png\" alt></p>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child1。有个缺点，从打印结果看出 Child1 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2)借助原型链实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 借助原型链实现继承\n *&#x2F;\nfunction Parent2() {\n    this.name = &quot;parent2&quot;;\n    this.play = [1, 2, 3];\n}\n\nfunction Child2() {\n    this.type = &quot;child2&quot;;\n}\nChild2.prototype = new Parent2();\n\nconsole.log(new Child2());\n\nvar s1 = new Child2();\nvar s2 = new Child2();\n</code></pre><p>打印：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-07.png\" alt></p>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.<strong>proto</strong> = 父亲对象的.prototype,但实际上我们是不能直接 操作<strong>proto</strong>，这时我们可以借用 new 来做，所以\nChild2.prototype = new Parent2(); &lt;=&gt; Child2.prototype.<strong>proto</strong> = Parent2.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.play 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.<strong>pro</strong> 和 s2.<strong>pro</strong>指向同一个地址即 父类的 prototype。</p>\n<h4>3)组合方式实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合方式\n *&#x2F;\n\nfunction Parent3() {\n    this.name = &quot;parent3&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent3.prototype.say = function() {};\n\nfunction Child3() {\n    Parent3.call(this);\n    this.type = &quot;child3&quot;;\n}\n\nChild3.prototype = new Parent3();\n\nvar s3 = new Child3();\nvar s4 = new Child3();\ns3.play.push(4);\nconsole.log(new Child3());\nconsole.log(s3.play, s4.play);\n</code></pre><p>打印:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-08.png\" alt></p>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 var s3 = new Child3()对应 Child3.prototype = new Parent3()还要 new 一次。</p>\n<h4>4)组合继承的优化 1</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent4() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent4.prototype.say = function() {};\n\nfunction Child4() {\n    Parent4.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild4.prototype = Parent4.prototype;\n\nvar s5 = new Child4();\nvar s6 = new Child4();\n</code></pre><p>这边主要为 Child4.prototype = Parent4.prototype， 因为我们通过构造函数就可以拿到所有属性和实例的方法，那么现在我想继承父类的原型对象，所以你直接赋值给我就行，不用在去 new 一次父类。其实这种方法还是有问题的，如果我在控制台打印以下两句:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-09.png\" alt></p>\n<p>从打印可以看出，此时我是没有办法区分一个对象 是直接 由它的子类实例化还是父类呢？我们还有一个方法判断来判断对象是否是类的实例，那就是用 constructor,我在控制台打印以下内容：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-10.png\" alt></p>\n<p>咦，你会发现它指向的是父类 ，这显然不是我们想要的结果， 上面讲过我们 prototype 里面有一个 constructor, 而我们此时子类的 prototype 指向是 父类的 prototye ,而父类 prototype 里面的 contructor 当然是父类自己的，这个就是产生该问题的原因。</p>\n<h4>组合继承的优化 2</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合继承的优化2\n *&#x2F;\n\nfunction Parent5() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent5.prototype.say = function() {};\n\nfunction Child5() {\n    Parent5.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild5.prototype = Object.create(Parent5.prototype);\n</code></pre><p>这里主要使用<strong>Object.create()</strong>，它的作用是将对象继承到<strong>proto</strong>属性上。举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>var test = Object.create({ x: 123, y: 345 });\nconsole.log(test); &#x2F;&#x2F;{}\nconsole.log(test.x); &#x2F;&#x2F;123\nconsole.log(test.__proto__.x); &#x2F;&#x2F;3\nconsole.log(test.__proto__.x === test.x); &#x2F;&#x2F;true\n</code></pre><p>那大家可能说这样解决了吗，其实没有解决,因为这时 Child5.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent5.prototype, constructor 还是 Parent5 ,所以要给 Child5.prototype 写自己的 constructor:</p>\n<pre class=\"prettyprint language-javascript\"><code>Child5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n</code></pre><h4>参考</h4>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23090041?refer=study-fe\">什么是 JS 原型链？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23804247\">this 的值到底是什么？一次说清楚</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23987456?refer=study-fe\">JS 的 new 到底是干什么的？</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>",
      "title": "搞懂 JavaScript 继承原理",
      "last_reply_at": "2019-02-13T02:54:22.173Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 407,
      "create_at": "2019-02-11T02:42:14.469Z",
      "author": {
        "loginname": "Fundebug",
        "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
      }
    },
    {
      "id": "5ab3166be7b166bb7b9eccf7",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>",
      "title": "【全文】狼叔：如何正确的学习Node.js",
      "last_reply_at": "2019-02-13T02:50:02.975Z",
      "good": true,
      "top": false,
      "reply_count": 97,
      "visit_count": 52025,
      "create_at": "2018-03-22T02:35:23.073Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
      }
    },
    {
      "id": "57356c5e8f82e08e531de6ca",
      "author_id": "532dbbb095db4c2478006daa",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>dotENV已经有很多模块，用得比较做的 dotenv，\n但是都是只支持一维的，我试着弄了个多维的，也就几十行代码：</p>\n<blockquote>\n<p>先放地址 <a href=\"https://github.com/captainblue2013/dotenvR\">https://github.com/captainblue2013/dotenvR</a></p>\n</blockquote>\n<hr>\n<h2>Install</h2>\n<pre class=\"prettyprint\"><code>npm install dotenvr --save\n</code></pre><h2>Usage</h2>\n<pre class=\"prettyprint\"><code>var config = require(&#x27;dotenvr&#x27;).load(); &#x2F;&#x2F;默认当前路径 .env \n&#x2F;&#x2F;var config = require(&#x27;dotenvr&#x27;).load(&#x27;&#x2F;path&#x2F;of&#x2F;your&#x2F;.env&#x27;);\n</code></pre><h2>Example</h2>\n<p>.env</p>\n<pre class=\"prettyprint\"><code> APP = demo\n A.B.C = 123\n</code></pre><p>var config = require(‘dotenvr’).load(); // also see process.env</p>\n<pre class=\"prettyprint\"><code> {\n     APP:&#x27;demo&#x27;,\n     A:{\n         B:{\n             C:123\n         }\n     }\n }</code></pre></div>",
      "title": "最近在用 dotENV ，于是做了一个支持多层的轮子",
      "last_reply_at": "2019-02-13T02:28:54.986Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 3414,
      "create_at": "2016-05-13T05:55:42.479Z",
      "author": {
        "loginname": "captainblue2013",
        "avatar_url": "https://avatars1.githubusercontent.com/u/3942299?v=4&s=120"
      }
    },
    {
      "id": "5c53f19f05cc322e7b136e1c",
      "author_id": "56ce68bc842c03521a73520e",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>在看《JavaScript高级程序设计》，章节6.2.2中最后（147页）提供了一种构造函数定义方式，但作者自己又说有问题，但并未讲清楚问题是什么，所以请大家讲讲？</p>\n<pre class=\"prettyprint\"><code>function Person(name, age, job){\n this.name = name;\n this.age = age;\n this.job = job;\n this.sayName = sayName;\n}\nfunction sayName(){\n alert(this.name);\n}\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\nperson1.sayName===person2.sayName; &#x2F;&#x2F; true\n</code></pre><p>这段代码的原文评注如下：\n在这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们\n将sayName 属性设置成等于全局的sayName 函数。这样一来，由于sayName 包含的是一个指向函数\n的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。这\n样做确实解决了两个函数做同一件事的问题，可是新问题又来了：<strong>在全局作用域中定义的函数实际上只\n能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方\n法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</strong></p>\n<p>有木有觉得粗体这段不知所云？</p>\n</div>",
      "title": "《JavaScript高级程序设计》中的一个疑点",
      "last_reply_at": "2019-02-13T01:48:09.794Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 854,
      "create_at": "2019-02-01T07:13:35.491Z",
      "author": {
        "loginname": "JarvisQJ",
        "avatar_url": "https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"
      }
    },
    {
      "id": "5c57980805cc322e7b1373ab",
      "author_id": "5ac77987e34737560fccaa7b",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><ul>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/love/dist/\">爱心闪烁效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/ballline/dist/\">简单的离子效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_fireworks/dist/\">简单的烟花效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_image_edit/dist/\">canvas实现图片裁切</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/BiuBiuBiu/dist/\">canvas射激光</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/paopao/dist/\">canvas实现鼠标跟踪动画</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/3d/dist/\">canvas实现3D文字</a></li>\n</ul>\n</div>",
      "title": "最近学习canvas，做了一些效果的合集",
      "last_reply_at": "2019-02-12T14:33:07.782Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 898,
      "create_at": "2019-02-04T01:40:24.214Z",
      "author": {
        "loginname": "BengBu-YueZhang",
        "avatar_url": "https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"
      }
    },
    {
      "id": "5c61274005cc322e7b137d2d",
      "author_id": "5ab852d6320bb09d69e231f1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>输入汉字拼音首字母,模糊查询数据,目前只有数据中预存拼音这一种方法么?比如数据库表中有name   pinyin2个字段\n\t里面存储数据 name:张三 pinyin:zhangsan,name:赵四 pinyin:zhaosi,查询输入zs,后台查询数据库pinyin这个字段,结果集为张三和赵四,就和高铁app上面查询车站那个搜索需求是一样的,主要前期设计数据库的时候没有设计pinyin这个字段,现在客户需求这个功能…有没有更好的办法解决呢?</p>\n</div>",
      "title": "请教:输入汉字拼音首字母,模糊查询数据",
      "last_reply_at": "2019-02-12T09:00:53.197Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 321,
      "create_at": "2019-02-11T07:41:52.403Z",
      "author": {
        "loginname": "iori2882",
        "avatar_url": "https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"
      }
    },
    {
      "id": "5c580a4105cc322e7b137466",
      "author_id": "5a751a679288dc81532884bf",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我现在有一套多项目多页面的前端代码，所有的项目都共用基础库（vue、echarts等）、公共js（自己写的公共方法以及配置）。大致结构如下\n<img src=\"//static.cnodejs.org/Fn2a95Q-cNNM5mm86EXMrUf0oasG\" alt=\"image.png\"></p>\n<p>说明：demo和test分别是两个独立的多页面项目，但是共用基础库（lib）和公共js（util）。基础库是长久不变的，可以由所有项目公用，但是公共js是可能变化的，所以我希望在打包的时候，公共js能打包到每个项目里面，这个项目的多个页面使用这一个公共js。 另外一个项目的多个页面，使用另外的公共js。</p>\n<p>如下图，希望的结果是util.js在demo/js和test/js下各有一分，demo和test分别引用各自js/下的的uitl。\n<img src=\"//static.cnodejs.org/Fj4rTRhh-879q4ltMlkqMrOGR8FI\" alt=\"image.png\"></p>\n<p>这样我就可以在修改公共代码后，只上传dist/demo，来达到只更新demo项目下的公共js的目的。\nutil配置代码是这样的：请问大佬，这个util怎么才能配置成活的呢\n<img src=\"//static.cnodejs.org/FsJzOidkWfIRmLbpcAvTeYHJgmzu\" alt=\"image.png\"></p>\n</div>",
      "title": "webpack4多页面多项目工程的公共js提取问题",
      "last_reply_at": "2019-02-12T08:52:09.271Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 625,
      "create_at": "2019-02-04T09:47:45.250Z",
      "author": {
        "loginname": "hejiaoshou",
        "avatar_url": "https://avatars0.githubusercontent.com/u/24504661?v=4&s=120"
      }
    },
    {
      "id": "5c6287ad05cc322e7b13816f",
      "author_id": "5af3dec21b02288048bd0eb1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>node的第三方模块中支持mysql schema的模块吗？像使用mongoose中的schema一样。</p>\n</div>",
      "title": "node的第三方模块中支持mysql schema的模块吗？",
      "last_reply_at": "2019-02-12T08:45:33.665Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 165,
      "create_at": "2019-02-12T08:45:33.665Z",
      "author": {
        "loginname": "witlxx",
        "avatar_url": "https://avatars0.githubusercontent.com/u/25942898?v=4&s=120"
      }
    },
    {
      "id": "5c6265b405cc322e7b138022",
      "author_id": "511350f6df9e9fcc58856443",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>前言</h1>\n<p>转眼新年过了，开始了搬砖的日子。在这里给大家拜个晚年，送上一些小知识，希望大家好搬砖！</p>\n<h1>klg-tracer</h1>\n<p>链路追踪工具，base on <a href=\"https://github.com/midwayjs/pandora\">pandora</a></p>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-bash\"><code>npm install klg-tracer\n</code></pre><p>Node.js &gt;= 8.2.1 required.</p>\n<h2>Features</h2>\n<p>Pandora 提供基于 OpenTracing 标准的链路追踪信息，在此基础上，klg-tracer 自定义了一些 tags，并支持将 tracer 信息写入 mongo。</p>\n<h2>QuickStart</h2>\n<h3>一、配合 Pandora 使用，自定义tags</h3>\n<p>TODO</p>\n<ol>\n<li>export 拓展好的类</li>\n<li>覆盖 Pandora 的默认配置</li>\n</ol>\n<h3>二、将 tracer 结果写入 Mongo</h3>\n<p>app.ts</p>\n<pre class=\"prettyprint language-js\"><code>import {TraceService, Tracer} from &#x27;klg-tracer&#x27;\n\nnew TraceService().registerHooks({\n    httpServer: {\n      useKoa:true, &#x2F;&#x2F; 在 koa 设置钩子，比直接在 http 层设置钩子稳定\n      &#x2F;&#x2F; 过滤器，只记录特定接口, 注意 return true 的才会被过滤\n      requestFilter: function (req) {\n        const urlParsed = url.parse(req.url, true);\n        return urlParsed.pathname.indexOf(&#x27;product&#x2F;&#x27;) === -1;\n      }\n    }\n  }).registerMongoReporter({\n    mongoUrl: config.database.mongodb[0].url,\n    collectionName: &#x27;tracer&#x27;\n  });\n\n</code></pre><p>完整的配置可以见 src/domain</p>\n<pre class=\"prettyprint language-typescript\"><code>interface TracerOptions {\n  httpServer?: {\n    recordGetParams?: boolean,    &#x2F;&#x2F; 是否记录 query\n    recordPostData?: boolean,     &#x2F;&#x2F; 是否记录 post data\n    recordResponse?: boolean,     &#x2F;&#x2F; 是否记录 response\n    requestFilter?: requestFilter,  &#x2F;&#x2F; 过滤器\n    interceptor?: interceptor       &#x2F;&#x2F; 中间件 TODO\n  },\n  httpClient?: {\n    enabled: boolean, options?: {\n      recordGetParams?: boolean,\n      recordPostData?: boolean,\n      recordResponse?: boolean\n    }\n  },\n  mongodb?: { enabled: boolean, options?: any }\n}\n</code></pre><p>启动你的 Web 服务并访问，相关的请求信息将会写入 tracer 表中。</p>\n<p>Search:</p>\n<pre class=\"prettyprint language-js\"><code>﻿db.tracer.find({name : &#x27;http-server&#x27;}).sort({_id : -1})\n</code></pre><p>Result:</p>\n<pre class=\"prettyprint language-js\"><code>{\n    &quot;_id&quot; : ObjectId(&quot;5ad99bd3f29cf14de64516b3&quot;),\n    &quot;tags&quot; : {\n        &quot;httpMethod&quot; : &quot;POST&quot;,\n        &quot;url&quot; : &quot;&#x2F;api&#x2F;v1&#x2F;account&#x2F;register&quot;,\n        &quot;data&quot; : {\n            &quot;userId&quot; : &quot;5527da927855af35354c39eb&quot;,\n            &quot;userRole&quot; : &quot;INVESTOR&quot;\n        },\n        &quot;response&quot; : {\n            &quot;code&quot; : 0,\n            &quot;message&quot; : &quot;success&quot;,\n            &quot;data&quot; : {\n                &quot;html&quot; : &quot;html&quot;\n            }\n        }\n    },\n    &quot;traceId&quot; : &quot;6e11fe95c2035a7a&quot;,\n    &quot;name&quot; : &quot;http-server&quot;,\n    &quot;timestamp&quot; : 1524210643694.0,\n    &quot;duration&quot; : 152,\n    &quot;createdAt&quot; : ISODate(&quot;2018-04-20T07:50:43.874Z&quot;),\n    &quot;updatedAt&quot; : ISODate(&quot;2018-04-20T07:50:43.874Z&quot;),\n    &quot;__v&quot; : 0\n}\n</code></pre><h3>Tracer tags</h3>\n<ol>\n<li>http server</li>\n</ol>\n<ul>\n<li>http.method</li>\n<li>http.path  // path</li>\n<li>http.query    // query string</li>\n<li>http.data  // post body, only json</li>\n<li>http.response</li>\n</ul>\n<ol>\n<li>http client</li>\n</ol>\n<ul>\n<li>http.method</li>\n<li>http.url  // path</li>\n<li>http.hostname  // send to where</li>\n<li>http.port</li>\n<li>http.query</li>\n<li>http.data</li>\n<li>http.response</li>\n<li>http.response_size</li>\n<li>http.status_code</li>\n<li>http.error_code</li>\n</ul>\n<ol>\n<li>mongo\ntodo</li>\n</ol>\n<h2>Test</h2>\n<pre class=\"prettyprint language-bash\"><code>$ npm i\n$ npm test\n</code></pre><h2>How it works</h2>\n<h3>tracer</h3>\n<p>implements session with <a href=\"https://nodejs.org/api/async_hooks.html\">async_hooks</a> and <a href=\"https://github.com/Jeff-Lewis/cls-hooked\">cls-hooked</a></p>\n<h3>hook</h3>\n<p>serve : hack http createServer method, register listener.</p>\n<p>http-client : hack http request method, register listener.</p>\n<h2>ChangeLog</h2>\n<p>3.0.0</p>\n<ul>\n<li>基于 Pandorajs 重做，目前只提供 http-server http-client mongo 三个位置的监听</li>\n</ul>\n<p>1.2.0</p>\n<ul>\n<li>koa-server hook add requestFilter options</li>\n</ul>\n<p>1.1.0</p>\n<ul>\n<li>koa-server hook add intercept options</li>\n</ul>\n<p>1.0.3</p>\n<ul>\n<li>http-client hook trace request parameters and response</li>\n</ul>\n<p>1.0.0</p>\n<ul>\n<li>add http-server koa-server hook</li>\n<li>add http-client hook</li>\n<li>add mongo report</li>\n</ul>\n<h2>常见问题</h2>\n<p>1 thenable 函数会 break cls 的上下文，像 mongoose 和 superagent 都是在 prototype 里添加 then function 来支持 Promise 的，所有都会有这个问题。\n目前只能通过改变写法来避免这个问题，例如：</p>\n<p>break session</p>\n<pre class=\"prettyprint language-js\"><code>await User.findOne({})\n</code></pre><p>work</p>\n<pre class=\"prettyprint language-js\"><code>await User.findOne({}).then()\n</code></pre><p>详情见此 issue <a href=\"https://github.com/midwayjs/pandora/issues/221\">https://github.com/midwayjs/pandora/issues/221</a></p>\n<p>2 mongodb nodejs driver 3.0 版本升级了 apm 的实现，Pandorajs 还未支持\n详情见此 issue <a href=\"https://github.com/midwayjs/pandora/issues/239\">https://github.com/midwayjs/pandora/issues/239</a></p>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>",
      "title": "AI考拉技术分享-Node基础架构专题（三）",
      "last_reply_at": "2019-02-12T06:20:36.609Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 217,
      "create_at": "2019-02-12T06:20:36.609Z",
      "author": {
        "loginname": "kalengo",
        "avatar_url": "https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"
      }
    },
    {
      "id": "5c62403805cc322e7b137f8b",
      "author_id": "58d140302c8bf2a836456213",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmrUNUrOP4SEOWrAMXQScFmOYqfR\" alt=\"js_closure.png\">\n<strong>摘要：</strong> 理解JS闭包。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017136436\">我从来不理解JavaScript闭包，直到有人这样向我解释它…</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>正如标题所述，JavaScript闭包对我来说一直有点神秘,看过很多闭包的文章，在工作使用过闭包，有时甚至在项目中使用闭包，但我确实是这是在使用闭包的知识。</p>\n<p>最近看国外的一些文章，终于，有人用于一种让我明白方式对闭包进行了解释，我将在本文中尝试使用这种方法来解释闭包。</p>\n<h3>准备</h3>\n<p>在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。</p>\n<p>这篇<a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\">文章</a>是执行上下文 很不错的入门教程，文章中提到：</p>\n<blockquote>\n<p>当代码在JavaScript中运行时，执行代码的环境非常重要，并将概括为以下几点：</p>\n<p><strong>全局代码</strong>——第一次执行代码的默认环境。</p>\n<p><strong>函数代码</strong>——当执行流进入函数体时。</p>\n<p>(…) —— 我们当作 执行上下文 是当前代码执行的一个环境与范围。</p>\n</blockquote>\n<p>换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么?</p>\n<p>以下几个步骤：</p>\n<ul>\n<li>JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。</li>\n<li>这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。</li>\n<li>新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>\n</ul>\n<p>函数什么时候结束?当它遇到一个return语句或一个结束括号}。</p>\n<p>当一个函数结束时，会发生以下情况:</p>\n<ul>\n<li>这个本地执行上下文从执行堆栈中弹出。</li>\n<li>函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined。</li>\n<li>这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。</li>\n</ul>\n<h4>基础的例子</h4>\n<p>在讨论闭包之前，让我们看一下下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>1: let a = 3\n2: function addTwo(x) {\n3:   let ret = x + 2\n4:   return ret\n5: }\n6: let b = addTwo(a)\n7: console.log(b)\n</code></pre><p>为了理解JavaScript引擎是如何工作的，让我们详细分析一下：</p>\n<ul>\n<li>在第1行，我们在全局执行上下文中声明了一个新变量a，并将赋值为3。</li>\n<li>接下来就变得棘手了，第2行到第5行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为<code>addTwo</code>的新变量,我们给它分配了什么?一个函数定义。两个括号{}之间的任何内容都被分配给<code>addTwo</code>，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。</li>\n<li>现在我们在第6行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为<code>b</code>，变量一经声明，其值即为undefined。</li>\n<li>接下来，仍然在第6行，我们看到一个赋值操作符。我们准备给变量<code>b</code>赋一个新值，接下来我们看到一个函数被调用。当您看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量<code>b</code>。</li>\n<li>但是首先我们需要调用标记为<code>addTwo</code>的函数。JavaScript将在其全局执行上下文内存中查找名为<code>addTwo</code>的变量。噢，它找到了一个，它是在步骤2(或第2 - 5行)中定义的。变量<code>add2</code>包含一个函数定义。注意，变量<code>a</code>作为参数传递给函数。JavaScript在全局执行上下文内存中搜索变量<code>a</code>，找到它，发现它的值是3，并将数字3作为参数传递给函数，准备好执行函数。</li>\n<li>现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo执行上下文”，执行上下文被推送到调用堆栈上。在addTwo执行上下文中，我们要做的第一件事是什么?</li>\n<li>你可能会说，“在addTwo执行上下文中声明了一个新的变量ret”，这是不对的。正确的答案是，我们需要先看函数的参数。在addTwo执行上下文中声明一个新的变量`x``，因为值3是作为参数传递的，所以变量x被赋值为3。</li>\n<li>下一步是:在addTwo执行上下文中声明一个新的变量<code>ret</code>。它的值被设置为 undefined(第三行)。</li>\n<li>仍然是第3行，需要执行一个相加操作。首先我们需要<code>x</code>的值，JavaScript会寻找一个变量<code>x</code>，它会首先在<code>addTwo</code>执行上下文中寻找，找到了一个值为3。第二个操作数是数字2。两个相加结果为5就被分配给变量<code>ret</code>。</li>\n<li>第4行，我们返回变量<code>ret</code>的内容，在addTwo执行上下文中查找，找到值为5，返回，函数结束。</li>\n<li>第4 - 5行，函数结束。addTwo执行上下文被销毁，变量<code>x</code>和<code>ret</code>被消去了，它们已经不存在了。addTwo执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数<code>addTw</code>o是从全局执行上下文调用的。</li>\n<li>现在我们继续第4步的内容，返回值5被分配给变量<code>b</code>，程序仍然在第6行。</li>\n<li>在第7行，<code>b</code>的值 5 被打印到控制台了。</li>\n</ul>\n<p>对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。</p>\n<h3>词法作用域（Lexical scope）</h3>\n<p>我们需要理解词法作用域的一些知识。请看下面的例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>1: let val1 = 2\n2: function multiplyThis(n) {\n3:   let ret = n * val1\n4:   return ret\n5: }\n6: let multiplied = multiplyThis(6)\n7: console.log(&#x27;example of scope:&#x27;, multiplied)\n</code></pre><p>这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。</p>\n<p>下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）：</p>\n<ul>\n<li>在全局执行上下文中声明一个新的变量<code>val1</code>，并将其赋值为2。</li>\n<li>行2 - 5，声明一个新的变量 <code>multiplyThis</code>，并给它分配一个函数定义。</li>\n<li>第六行，声明一个在全局执行上下文 <code>multiplied</code> 新变量。</li>\n<li>从全局执行上下文内存中查找变量<code>multiplyThis</code>，并将其作为函数执行，传递数字 6 作为参数。</li>\n<li>新函数调用(创建新执行上下文），创建一个新的 <code>multiplyThis</code> 函数执行上下文。</li>\n<li>在 <code>multiplyThis</code> 执行上下文中，声明一个变量n并将其赋值为6</li>\n<li>第 3 行。在<code>multiplyThis</code>执行上下文中，声明一个变量<code>ret</code>。</li>\n<li>继续第 3 行。对两个操作数 n 和 val1 进行乘法运算.在<code>multiplyThis</code>执行上下文中查找变量 <code>n</code>。我们在步骤6中声明了它,它的内容是数字6。在<code>multiplyThis</code>执行上下文中查找变量<code>val1</code>。<code>multiplyThis</code>执行上下文没有一个标记为 val1 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 <code>val1</code>。哦，是的、在那儿，它在步骤1中定义，数值是2。</li>\n<li>继续第 3 行。将两个操作数相乘并将其赋值给<code>ret</code>变量，6 * 2 = 12，ret现在值为 12。</li>\n<li>返回<code>ret</code>变量，销毁<code>multiplyThis</code>执行上下文及其变量 <code>ret</code> 和 <code>n</code> 。变量 <code>val1</code> 没有被销毁，因为它是全局执行上下文的一部分。</li>\n<li>回到第6行。在调用上下文中，数字 12 赋值给 <code>multiplied</code> 的变量。</li>\n<li>最后在第7行，我们在控制台中打印 <code>multiplied</code> 变量的值</li>\n</ul>\n<p>在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是<strong>词法作用域（Lexical scope）</strong>。</p>\n<h3>返回函数的函数</h3>\n<p>在第一个例子中，函数<code>addTwo</code>返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于理解闭包非常重要。看粟子：</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: let val = 7\n 2: function createAdder() {\n 3:   function addNumbers(a, b) {\n 4:     let ret = a + b\n 5:     return ret\n 6:   }\n 7:   return addNumbers\n 8: }\n 9: let adder = createAdder()\n10: let sum = adder(val, 8)\n11: console.log(&#x27;example of function returning a function: &#x27;, sum)\n</code></pre><p>让我们回到分步分解：</p>\n<ul>\n<li>第一行。我们在全局执行上下文中声明一个变量<code>val</code>并赋值为 7。</li>\n<li>行2 - 8。我们在全局执行上下文中声明了一个名为 <code>createAdder</code> 的变量，并为其分配了一个函数定义。第3至7行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量(<code>createAdder</code>)中。</li>\n<li>第9行。我们在全局执行上下文中声明了一个名为 <code>adder</code> 的新变量，暂时，值为 undefined。</li>\n<li>第9行。我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为<code>createAdder</code> 的变量，它是在步骤2中创建的。好吧，我们调用它。</li>\n<li>调用函数时，执行到第2行。创建一个新的<code>createAdder</code>执行上下文。我们可以在<code>createAdder</code>的执行上下文中创建自有变量。js 引擎将<code>createAdder</code>的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分.</li>\n<li>第 3 - 6 行。我们有一个新的函数声明，我们在<code>createAdder</code>执行上下文中创建一个变量addNumbers。这很重要，<code>addnumber</code>只存在于<code>createAdder</code>执行上下文中。我们将函数定义存储在名为 `addNumbers`` 的自有变量中。</li>\n<li>在第7行，我们返回变量<code>addNumbers</code>的内容。js引擎查找一个名为<code>addNumbers</code>的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返<code>addNumbers</code>的定义。第4行和第5行括号之间的内容构成该函数定义。</li>\n<li>返回时，<code>createAdder</code>执行上下文将被销毁。<code>addNumbers</code> 变量不再存在。但<code>addNumbers</code>函数定义仍然存在，因为它返回并赋值给了adder 变量。</li>\n<li>第10行。我们在全局执行上下文中定义了一个新的变量 <code>sum</code>，先负值为 undefined;</li>\n<li>接下来我们需要执行一个函数。哪个函数?是名为<code>adder</code>变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。</li>\n<li>让我们查找这两个参数，第一个是我们在步骤1中定义的变量<code>val</code>，它表示数字7，第二个是数字8。</li>\n<li>现在我们要执行这个函数，函数定义概述在第3-5行，因为这个函数是匿名，为了方便理解，我们暂且叫它<code>adder</code>吧。这时创建一个<code>adder</code>函数执行上下文，在<code>adder</code>执行上下文中创建了两个新变量 <code>a</code> 和 <code>b</code>。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。</li>\n<li>第 4 行。在<code>adder</code>执行上下文中声明了一个名为<code>ret</code>的新变量,</li>\n<li>第 4 行。将变量<code>a</code>的内容和变量<code>b</code>的内容相加得15并赋给ret变量。</li>\n<li><code>ret</code>变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量<code>a</code>、<code>b</code>和<code>ret</code>不再存在。</li>\n<li>返回值被分配给我们在步骤9中定义的<code>sum</code>变量。</li>\n<li>我们将<code>sum</code>的值打印到控制台。</li>\n<li>如预期，控制台将打印15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到return或右括号}时执行完成。</li>\n</ul>\n<p><strong>码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>最后,一个闭包</h3>\n<p>看看下面的代码，并试着弄清楚会发生什么。</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log(&#x27;example increment&#x27;, c1, c2, c3)\n</code></pre><p>现在，我们已经从前两个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它：</p>\n<ul>\n<li>行1 - 8。我们在全局执行上下文中创建了一个新的变量<code>createCounter</code>，并赋值了一个的函数定义。</li>\n<li>第9行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li>\n<li>第9行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li>\n<li>行1 - 8。调用函数，创建新的本地执行上下文。</li>\n<li>第2行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 0;</li>\n<li>行3 - 6。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是为第4行和第5行所定义。</li>\n<li>第7行。返回<code>myFunction</code>变量的内容，删除本地执行上下文。变量<code>myFunction</code>和<code>counter</code>不再存在。此时控制权回到了调用上下文。</li>\n<li>第9行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值赋给了<code>increment</code>，变量<code>increment</code>现在包含一个函数定义内容为<code>createCounter</code>返回的函数。它不再标记为<code>myFunction``，但它的定义是相同的。在全局上下文中，它是的标记为</code>labeledincrement`。</li>\n<li>第10行。声明一个新变量(c1)。</li>\n<li>继续第10行。查找<code>increment</code>变量，它是一个函数并调用它。它包含前面返回的函数定义，如第4-5行所定义的。</li>\n<li>创建一个新的执行上下文。没有参数。开始执行函数。</li>\n<li>第4行。counter=counter + 1。在本地执行上下文中查找<code>counter</code>变量。我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有<code>counter</code>变量。Javascript会将其计算为counter = undefined + 1，声明一个标记为<code>counter</code>的新局部变量，并将其赋值为number 1，因为undefined被当作值为 0。</li>\n<li>第5行。我们变量<code>counter</code>的值(1)，我们销毁本地执行上下文和<code>counter</code>变量。</li>\n<li>回到第10行。返回值(1)被赋给c1。</li>\n<li>第11行。重复步骤10-14，c2也被赋值为1。</li>\n<li>第12行。重复步骤10-14，c3也被赋值为1。</li>\n<li>第13行。我们打印变量c1 c2和c3的内容。</li>\n</ul>\n<p>你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录1,1,1。而是记录1,2,3。这个是为什么?</p>\n<p>不知怎么滴，<code>increment</code>函数记住了那个<code>cunter</code>的值。这是怎么回事?</p>\n<p><code>counter</code>是全局执行上下文的一部分吗?尝试 console.log(counter)，得到undefined的结果,显然不是这样的。</p>\n<p>也许，当你调用<code>increment</code>时，它会以某种方式返回它创建的函数(createCounter)?这怎么可能呢?变量<code>increment</code>包含函数定义，而不是函数的来源，显然也不是这样的。</p>\n<p>所以一定有另一种机制。<strong>闭包</strong>，我们终于找到了，丢失的那块。</p>\n<p>它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。</p>\n<p>所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的。</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log(&#x27;example increment&#x27;, c1, c2, c3)\n</code></pre><ul>\n<li>同上， 行1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。</li>\n<li>同上，第9行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li>\n<li>同上，第9行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li>\n<li>同上，行1 - 8。调用函数，创建新的本地执行上下文。</li>\n<li>同上，第2行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 0 。</li>\n<li>行3 - 6。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量<code>counter</code>(值为0)。</li>\n<li>第7行。返回<code>myFunction</code>变量的内容,删除本地执行上下文。<code>myFunction</code>和<code>counter</code>不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。</li>\n<li>第9行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值被指定为<code>increment</code>，变量<code>increment</code>现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为<code>myFunction</code>，但它的定义是相同的,在全局上下文中，称为<code>increment</code>。</li>\n<li>第10行。声明一个新变量(c1)。</li>\n<li>继续第10行。查找变量<code>increment</code>，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。</li>\n<li>创建一个新的执行上下文，没有参数，开始执行函数。</li>\n<li>第4行。counter = counter + 1，寻找变量 <code>counter</code>，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为<code>counter</code>的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 <code>counter</code>。</li>\n<li>第5行。我们返回<code>counter的值</code>，销毁本地执行上下文。</li>\n<li>回到第10行。返回值(1)被赋给变量<code>c1</code>。</li>\n<li>第11行。我们重复步骤10-14。这一次，在闭包中此时变量<code>counter</code>的值是1。它在第12步设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。</li>\n<li>第12行。重复步骤10-14,<code>c3</code>被赋值为3。</li>\n<li>第13行。我们打印变量c1 c2和c3的值。</li>\n</ul>\n<p>您可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数?答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。</p>\n<p>当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。</p>\n<h3>闭包不是那么简单</h3>\n<p>有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例，如下面的代码所示：</p>\n<pre class=\"prettyprint language-javascript\"><code>let c = 4\nconst addX = x =&gt; n =&gt; n + x\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log(&#x27;example partial application&#x27;, d)\n</code></pre><p>如果箭头函数让您感到困惑，下面是同样效果：</p>\n<pre class=\"prettyprint language-javascript\"><code>let c = 4\nfunction addX(x) {\n  return function(n) {\n     return n + x\n  }\n}\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log(&#x27;example partial application&#x27;, d)\n</code></pre><p>我们声明一个能用加法函数<code>addX</code>，它接受一个参数(x)并返回另一个函数。返回的函数还接受一个参数并将其添加到变量<code>x</code>中。</p>\n<p>变量<code>x</code>是闭包的一部分，当变量<code>addThree</code>在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量x。</p>\n<p>所以当<code>addThree</code>被调用并执行时，它可以从闭包中访问变量<code>x</code>以及为参数传递变量<code>n</code>并返回两者的和 7。</p>\n<h3>总结</h3>\n<p>我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2017/07/31/javascript-closure/\">解密JavaScript闭包</a></li>\n<li><a href=\"https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/\">10个JavaScript难点</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>",
      "title": "我从来不理解JavaScript闭包，直到有人这样向我解释它...",
      "last_reply_at": "2019-02-12T03:40:40.147Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 565,
      "create_at": "2019-02-12T03:40:40.147Z",
      "author": {
        "loginname": "Fundebug",
        "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
      }
    },
    {
      "id": "5c0a92e415a4d545e3f4c5d7",
      "author_id": "5bc9f0ca9545eaf107b9ccdd",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>要怎么去学习</p>\n</div>",
      "title": "如何学习angular",
      "last_reply_at": "2019-02-12T03:30:02.714Z",
      "good": false,
      "top": false,
      "reply_count": 14,
      "visit_count": 1332,
      "create_at": "2018-12-07T15:33:56.403Z",
      "author": {
        "loginname": "hhffhh",
        "avatar_url": "https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"
      }
    },
    {
      "id": "5c622b8805cc322e7b137ef2",
      "author_id": "5c47daf86955112b99437e57",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"http://uyi2.com\">网盘下载地址</a>\n<img src=\"http://static.vue-js.com/FkCSj9gakP2tIdjc0Ha7GZHuJvrx\" alt=\"image.png\"></p>\n</div>",
      "title": "慕课网付费视频免费开放，定期更新。",
      "last_reply_at": "2019-02-12T02:43:34.175Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 390,
      "create_at": "2019-02-12T02:12:24.607Z",
      "author": {
        "loginname": "xiaozhimn",
        "avatar_url": "https://avatars1.githubusercontent.com/u/4102025?v=4&s=120"
      }
    },
    {
      "id": "5c614c7fe6aaad2ea76df78a",
      "author_id": "5a77fac6afa0a121784a9300",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-vue\"><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  import VueRouter from &#x27;vue-router&#x27;;\n  import PostList from &#x27;.&#x2F;posts&#x27;;\n\n  export default {\n    props: [&#x27;outside&#x27;],\n    router: new VueRouter({\n      mode: &#x27;history&#x27;,\n      routes: [{\n        path: &#x27;&#x2F;&#x27;,\n        component: PostList,\n        name: &#x27;post_index&#x27;,\n        props: {outside: outside}\n      }]\n    })\n  };\n&lt;&#x2F;script&gt;\n</code></pre><p>本身是个组件，请问我要怎么在这里把<code>outside</code>的参数传给<code>PostList</code>这个组件</p>\n</div>",
      "title": "问一个关于Vue路由初始化时传默认参数的问题",
      "last_reply_at": "2019-02-11T15:39:38.255Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 202,
      "create_at": "2019-02-11T10:20:47.891Z",
      "author": {
        "loginname": "jiyarong",
        "avatar_url": "https://avatars2.githubusercontent.com/u/8100962?v=4&s=120"
      }
    },
    {
      "id": "5b3ad07657137f22415c5262",
      "author_id": "5ad06588a7d228c16b986a94",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>反面例子1：</p>\n<pre class=\"prettyprint\"><code>function abc(a: string, b: number): void;\nfunction abc(a: string): void;\nfunction abc(a: any, b:any): void {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>反面例子2：</p>\n<pre class=\"prettyprint\"><code>interface IAbc {\n\t(a: string, b: number): void;\n\t(a: string): void;\n\tsomeAttr: ()=&gt;void;\n}\nlet abc: IAbc = (a: any, b:any) =&gt; {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>现在这样凑合着：</p>\n<pre class=\"prettyprint\"><code>interface IAbc {\n\t(a: string, b: number): void;\n\t(a: string): void;\n\tsomeAttr?: ()=&gt;void; &#x2F;&#x2F; 加了个问号\n}\nlet abc: IAbc = (a: any, b?:any) =&gt; {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>请问有人知道正确手法吗？</p>\n</div>",
      "title": "TypeScript 中应如何声明一个函数，之后给它添加静态属性？",
      "last_reply_at": "2019-02-11T15:35:20.549Z",
      "good": false,
      "top": false,
      "reply_count": 22,
      "visit_count": 2998,
      "create_at": "2018-07-03T01:25:10.884Z",
      "author": {
        "loginname": "xyzingh",
        "avatar_url": "https://avatars0.githubusercontent.com/u/32507398?v=4&s=120"
      }
    },
    {
      "id": "5c22034c3898674067a783fc",
      "author_id": "5b52cbf1fb9e84ec69cc1ca2",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>Vscode编辑器用中Angular7提示工具下载量马上达到750万，这意味这说什么？</p>\n<p>说实话Angular7.x相比React vue有更快的编译速度、更快的运行速度。难道王者归来。</p>\n<p><strong>Angular7入门视频教程网盘免费下</strong>：   <a href=\"https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g\">https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g</a></p>\n<p><img src=\"//static.cnodejs.org/Fp_oe68CGoTo4J8Vbpcqc_dVAFhQ\" alt=\"1.png\"></p>\n</div>",
      "title": "Vscode编辑器中Angular7提示工具下载量达到750万 -这意味着什么？ 王者归来来吗？",
      "last_reply_at": "2019-02-11T13:02:35.051Z",
      "good": false,
      "top": false,
      "reply_count": 23,
      "visit_count": 2035,
      "create_at": "2018-12-25T10:15:40.046Z",
      "author": {
        "loginname": "nodeper",
        "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
      }
    },
    {
      "id": "5c53ee2305cc322e7b136ded",
      "author_id": "5a7ec2c48d6e16e56bb806d7",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>不是读取网站目录拿到、我想要通过api接口获得，应该如何操作？\n默认创建账户method：personal_newAccount是拿不到这些的，不耻下问。</p>\n</div>",
      "title": "请问以太坊创建账户如何拿到他的keystore和privatekey？",
      "last_reply_at": "2019-02-11T11:12:29.375Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 460,
      "create_at": "2019-02-01T06:58:43.877Z",
      "author": {
        "loginname": "onesez",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16702534?v=4&s=120"
      }
    },
    {
      "id": "5c440ba76955112b99436f07",
      "author_id": "5ab852d6320bb09d69e231f1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>在网络上大概搜索一下,好像是不能?虽然说Java编译的代码也能反编译(一般人还是反编译不了的)…但是直接把代码裸着部署在客户的服务器上不好吧?随随便便拷贝一下懂一些JS就能直接修改代码了…最重要的是,node.js做出来的产品在客户的服务器上部署并想按年授权收费是不是就没有办法了?还得用Java等语言重做?\n代码混淆jshaman挺好的,但是他们的代码混淆竟然不支持ES6语法~~~~~~~~~~~\n大家都是怎么弄得啊?还是大家都没有把服务端部署在客户本地服务器上的需求?</p>\n</div>",
      "title": "node.js能像Java一样编译代码么?",
      "last_reply_at": "2019-02-11T07:33:57.952Z",
      "good": false,
      "top": false,
      "reply_count": 16,
      "visit_count": 1322,
      "create_at": "2019-01-20T05:48:23.439Z",
      "author": {
        "loginname": "iori2882",
        "avatar_url": "https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"
      }
    },
    {
      "id": "5c61232c05cc322e7b137d0e",
      "author_id": "5c47daf86955112b99437e57",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"http://uyi2.com\">下载地址</a>\n<img src=\"//static.cnodejs.org/FsUtVJ-iPxzBmZGlrnNdropb0NYT\" alt=\"ue2.png\"></p>\n</div>",
      "title": "nodejs 培训机构实战教程免费下载",
      "last_reply_at": "2019-02-11T07:24:28.685Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 271,
      "create_at": "2019-02-11T07:24:28.685Z",
      "author": {
        "loginname": "xiaozhimn",
        "avatar_url": "https://avatars1.githubusercontent.com/u/4102025?v=4&s=120"
      }
    },
    {
      "id": "5c5a8f5105cc322e7b137632",
      "author_id": "556150874eb040084cfe5dcb",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>在线试用</h2>\n<p><a href=\"https://music.xinshangshangxin.com\">https://music.xinshangshangxin.com</a></p>\n<h2>github</h2>\n<p><a href=\"https://github.com/xinshangshangxin/music\">https://github.com/xinshangshangxin/music</a></p>\n<h2>界面说明</h2>\n<p><img src=\"//static.cnodejs.org/FlVr2g5AQa9uvyvMl1lGpwKgSciJ\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FuxFd6aVqrX0QtkLNma7cLY0Xhdi\" alt=\"image.png\"></p>\n<h2>框架</h2>\n<p>前端  <code>Angular 6</code>, 后端  <code>nestjs</code> + <code>graphql</code>\n若有纰漏请大家补充指正~</p>\n<h2>其它</h2>\n<p><a href=\"https://github.com/xinshangshangxin/MusicPlayer/tree/v1\">早期 jQuery 写的音乐播放器</a>\n<a href=\"https://github.com/xinshangshangxin/MusicPlayer\">早期 angularjs(1.x) 写的音乐播放器</a></p>\n</div>",
      "title": "每首歌只听最High部分的音乐播放器(支持酷狗/网易/虾米)[Angular + nestjs]",
      "last_reply_at": "2019-02-11T07:17:56.996Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 523,
      "create_at": "2019-02-06T07:40:01.679Z",
      "author": {
        "loginname": "xinshangshangxin",
        "avatar_url": "https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"
      }
    },
    {
      "id": "5c5fd3c305cc322e7b137a25",
      "author_id": "591eea623504ce1c2ac45e58",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>先放链接：<a href=\"https://github.com/vincent178/flexrouter\">https://github.com/vincent178/flexrouter</a></p>\n<h2>为什么重新发明一个路由轮子？</h2>\n<p>react-router vue-router express 还有koa 都是用的 path-to-regexp, 将路由转化成正则表达式，然后循环比对当前路径找到符合的路由。在大量路由情况下查找性能会比较差。 Go 有个高性能的http路由 <a href=\"https://github.com/julienschmidt/httprouter%EF%BC%8C\">https://github.com/julienschmidt/httprouter，</a> 内部使用 Radix Tree 实现高性能路由查找，我也撸了一个 ts 版本的。</p>\n<h2>特性</h2>\n<p><strong>支持前端和后端:</strong></p>\n<p>后端例子没有用任何node框架 http 路由 <a href=\"https://github.com/vincent178/flexrouter/tree/master/examples/http-server-with-flexrouter\">https://github.com/vincent178/flexrouter/tree/master/examples/http-server-with-flexrouter</a>\n前端例子是 react 页面路由 <a href=\"https://github.com/vincent178/flexrouter/tree/master/examples/react-router-with-flexrouter\">https://github.com/vincent178/flexrouter/tree/master/examples/react-router-with-flexrouter</a></p>\n<p><strong>高性能:</strong></p>\n<p>在2000+路由的情况下，benchmark数据</p>\n<pre class=\"prettyprint\"><code>path-to-regexp#home x 4,247 ops&#x2F;sec ±1.82% (83 runs sampled)\nflexrouter#home x 4,856,189 ops&#x2F;sec ±0.71% (88 runs sampled)\npath-to-regexp#topic-detail x 4,247 ops&#x2F;sec ±1.33% (86 runs sampled)\nflexrouter#topic-detail x 1,254,182 ops&#x2F;sec ±0.82% (88 runs sampled)\n</code></pre><p><strong>多种格式支持:</strong>\nstatic route: <code>/home</code>\nparam route: <code>/topic/:id</code>\nparam route with regex: <code>topic/photo-:id(/\\\\d+/).jpg</code>\nwildcard route: <code>/*site</code></p>\n<p>其他细节 <a href=\"https://github.com/vincent178/flexrouter\">https://github.com/vincent178/flexrouter</a></p>\n<p>fastify也有个类似的实现叫 find-my-way， 但是它实现有点问题，这也是我想自己实现一个版本的原因。</p>\n</div>",
      "title": "高性能基数树路由库 flexrouter，能同时和React和koa一起用的路由库",
      "last_reply_at": "2019-02-11T04:33:12.851Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 297,
      "create_at": "2019-02-10T07:33:23.481Z",
      "author": {
        "loginname": "vincent178",
        "avatar_url": "https://avatars2.githubusercontent.com/u/2183720?v=4&s=120"
      }
    },
    {
      "id": "5c5fd8d205cc322e7b137a2f",
      "author_id": "5a49efecf320ae9f0dd5821a",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>《软硬结合——从零打造物联网》</strong>，这个教程起源于我两年前做毕业设计时太累了，踩了不少坑，所以决定等有空的时候就整理写一份教程，毕竟自己走过的弯路，可以告诉别人不必再走。<strong>通过此教程，吸引更多人到nodejs开发~</strong></p>\n<h2>教程主要内容</h2>\n<ol>\n<li>告诉大家javascript是个好东西，特别是对于一个人要做所有事的时候，原因如图所示：\n<img src=\"http://ww1.sinaimg.cn/large/005BIQVbgy1fy6ia4qfrdj30nb0ebqm0.jpg\" alt=\"无所不能的JS\"></li>\n<li>在教程里写了demo1与demo2\ndemo1演示了最简单的物联网项目：通过手机控制LED灯开关。硬件上使用淘宝价十几块钱的nodemcu。\ndemo2在demo1的基础上引入了 增加实时性的websocket、数据可视化echart、数据库mongodb。\n为更好地突显javascript的优越性，还完成了<strong>微信小程序</strong>、<strong>.exe应用</strong>以供参考。</li>\n<li>为了保证傻瓜式教学，我录了很多短视频以保证新手们跟着做没有错，并且制作了大量图片以免全是文字导致教程太无聊，</li>\n<li>还简单地讨论了通信协议等内容（TCP、HTTP、websocket、MQTT），让大家学习网络知识。</li>\n<li>本教程会让你学习其它大量的教程，阅读大量的书籍，别人制作得很好的教程我就不重复写。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/005BIQVbgy1fzbotaayifj30lu0coab7.jpg\" alt></p>\n<h2>最后</h2>\n<p>由于我还是萌新，所制作的教程会受限于个人经验不足，但我会长期维护，随着大家学习时提出的问题，我会完善教程对应不足的地方，编写FAQ。欢迎大家把这教程分享给有需要的人，欢迎大佬们指出不足，我会花时间去做修改。希望此教程能帮到有需要的人。</p>\n<ul>\n<li><a href=\"https://www.scaugreen.cn/posts/44755/\">在线浏览</a></li>\n<li><a href=\"https://github.com/alwxkxk/soft-and-hard\">github</a></li>\n</ul>\n<p><img src=\"https://camo.githubusercontent.com/f5cbcbeb3c56970bf24be29cd48e348316d1f2ac/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f3030354249515662677931667a36647530756267346a333168633071323761392e6a7067\" alt=\"软硬结合\"></p>\n</div>",
      "title": "基于javascript全栈的物联网入门教程——《软硬结合，从零打造物联网》",
      "last_reply_at": "2019-02-11T04:13:24.761Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 427,
      "create_at": "2019-02-10T07:54:58.989Z",
      "author": {
        "loginname": "alwxkxk",
        "avatar_url": "https://avatars2.githubusercontent.com/u/16029024?v=4&s=120"
      }
    },
    {
      "id": "5c5ae92be6aaad2ea76deff8",
      "author_id": "57f2384783a4d9176a71da75",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>本文 context ：面向于 C 端的产品/公司；</p>\n</blockquote>\n<blockquote>\n<p>本文核心不是强调某一个岗位，而是应该“离业务更近”，“离用户更近”</p>\n</blockquote>\n<p>在现代的工业体系下，任何工作都被拆分为流水线上的一环，如今的互联网行业更是从用户那里知道他们想要什么再到实际做出来，有足足六七个环节。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fzwukjnuwcj31220ggwey.jpg\" alt></p>\n<p>作为一个有写代码爱好的人来说，能选择的余地不多，唯有「<strong>后端工程师</strong>」和「<strong>前端工程师</strong>」，在过去的很长时间，我基本上呆在后端的领域，去做了很多后端相关的开发，自己也在后端方面有了更多的认识。</p>\n<p>在新的 2019 年，我将会尝试让自己转向，成为一个前端工程师。接下来，我来说一说我这个选择的背后逻辑。</p>\n<h2>员工的价值到底由什么决定？</h2>\n<blockquote>\n<p>白子：离客户越近，其价值就越大。</p>\n</blockquote>\n<p>提到择业，就避不开两个话题，企业的需求和员工的价值。一般来说，我们认为，<strong>员工的价值由他为企业带来的价值所决定</strong>。</p>\n<p>这句话没错，那么，员工如何为企业带来价值？</p>\n<p>员工可以帮助企业创造更好的产品，但是，<strong>这是价值么？</strong></p>\n<p>更好的产品本身并不是价值，<strong>其所带来的用户、客户才是真正的价值</strong>。</p>\n<p>员工本身并不让企业盈利，相反，企业需要支付费用给员工。而客户则是支付费用给公司，帮助企业盈利。</p>\n<p>从这个角度来看，<strong>离客户越近的人，越能产生价值</strong>，这也就是为什么我们会经常看到一个企业里，销售是赚钱最多的人，因为他们离客户最近，能够给企业带来实打实的价值。</p>\n<h2>技术背后的陷阱</h2>\n<blockquote>\n<p>白子：技术本身就是螺丝钉，只研技术，不过是一个螺丝钉，变成一个更粗的螺丝钉。</p>\n</blockquote>\n<p>关注技术本身有没有坏处？当然没有，作为一个开发者，追求技术的卓越是应有的义务。但是，从企业的角度来说，<strong>只关注技术本身，意味着你的价值会不断降低。</strong></p>\n<p>技术再强，也是可以找到替代者的，区别仅仅是愿不愿意花那么多钱罢了。业务理解的深度，却是其他人无法轻易替代的。江山代有才人出，各领风骚数百年，技术迭代速度非常快，总会有新人出来，比你更加擅长技术。</p>\n<h2>为什么是前端不是后端</h2>\n<blockquote>\n<p>白子：如今的前端更加接近业务本身，更具备价值</p>\n</blockquote>\n<p>随着现代软件产品的高度流水线化，我们推崇的<strong>前后端分离、RESTFul API、GraphQL 让后端的工作越来越轻松</strong>，可以花费更多的精力投放在技术深度的探索，去研究更加深层次的优化问题，而不需要花费更多的心思在业务逻辑上去。</p>\n<p>同样的，<strong>前端不得不承担起业务流程的开发，工作量大大加大</strong>。虽然有各种各样的组件库帮助前端优化了具体布局、界面上面的工作，<strong>但业务流程本身的复杂度并不会因为组件库的引入而简化</strong>。</p>\n<p>在这种强前端重后端的模式下，前端承担了原本是后端的工作，让后端不再需要去理解业务逻辑，更加关注技术本身的内容就可以了。<strong>离业务越来越远，使得后端的话语权越来越小。</strong></p>\n<h2>游刃有余的前端</h2>\n<p><strong>前端工程师本身负责的是客户可以看见的内容，这使得他们相比于后端工程师，有着更多的职业选择</strong>。</p>\n<p>他们了解用户交互体验，可以从开发转换成为用户研究</p>\n<p>他们了解用户使用方法，可以从开发转换成为销售</p>\n<p>他们了解用户使用路径，可以从开发转换成为产品经理</p>\n<p><strong>而后端，由于专精于技术，其职业选择，也不过是从一门技术，转为另外一门技术罢了。</strong></p>\n</div>",
      "title": "离用户近一点，再近一点",
      "last_reply_at": "2019-02-11T03:42:17.779Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 624,
      "create_at": "2019-02-06T14:03:23.234Z",
      "author": {
        "loginname": "bestony",
        "avatar_url": "https://avatars1.githubusercontent.com/u/13283837?v=4&s=120"
      }
    },
    {
      "id": "5c54046c05cc322e7b136ea7",
      "author_id": "57d216e13d3520a5387c2b53",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我知道一般程序员做笔记都用markdown，但是支持markdown的笔记软件也有很多。</p>\n<p>我之前都是用txt。\n优点只有一个：方便</p>\n<p>缺点一堆</p>\n<p>求推荐一个用起来顺手的。最好能登陆更新那种的。</p>\n</div>",
      "title": "大家好，问个问题，请问大家遇到做笔记的时候用什么软件啊",
      "last_reply_at": "2019-02-11T02:02:44.194Z",
      "good": false,
      "top": false,
      "reply_count": 14,
      "visit_count": 858,
      "create_at": "2019-02-01T08:33:48.295Z",
      "author": {
        "loginname": "a69694510",
        "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
      }
    },
    {
      "id": "5c4fffe0a4647e02328f206f",
      "author_id": "52c005d28a716e0b1578f9cc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>大家好，很开心在这里宣布 YodaOS 开源了。他将承载 Rokid 4年以来对于人工智能和语音交互领域的沉淀，并选择 Node.js 作为操作系统的一等开发公民，全部开放给社区。</p>\n<p><img src=\"//static.cnodejs.org/FonFMOGJSL2v_OCVBkKULbZs2IJR\" alt=\"yoda-arch.png\"></p>\n<p>YodaOS 的架构跟 Android 类似，从下至上，由 Linux Kernel、系统服务和应用框架组成。不过 YodaOS 有以下不同：</p>\n<ul>\n<li>开发者可以直接使用 JavaScript / Node.js 来开发本地应用（技能）；</li>\n<li>封装了 AI 抽象层，可以通过 JavaScript 直接调用到诸如语音激活、语音识别、人脸识别等接口；</li>\n</ul>\n<p>除了支持默认的 Node.js API 外，YodaOS 还提供：</p>\n<ul>\n<li>内置的语音激活和语音识别 API，真正做到了开箱即用（开发）的语音交互系统；</li>\n<li>对音量控制、电源管理、蓝牙、多媒体播放、LED 灯效和 OTA 等都进行了接口封装；</li>\n<li>对物联网开发者来说，内置了标准化的 WebSocket、MQTT 等物联网协议的客户端实现；</li>\n</ul>\n<p>YodaOS 也支持 npm 仓库，开发者可以根据自己的需要在 OS 中运行所需的模块，不过并不推荐使用一些实现起来很重的模块，因为 YodaOS 需要支持中低端设备，所以有时候也需要考虑到性能方面的因素。</p>\n<p>如果遇到一些 npm 仓库确实实现很重，但又不得不用的时候，在 YodaOS 上，我们一般的做法是使用 N-API 桥接 C/C++ 模块，然后保证 JavaScript API 与对应的 npm 包一致。</p>\n<p>同时借助于 N-API，开发者可以将任何 Linux 的库移植到 YodaOS 上，并通过 N-API 以 JavaScript API 方式使用，可以这么理解，N-API 之于 YodaOS，就像 JNI 之于 Android。</p>\n<p><img src=\"//static.cnodejs.org/FkOaVJ5f8rc8m3a_be8D0uQpuBJM\" alt=\"yoda-nodejs.png center\"></p>\n<h3>为什么是 Node.js</h3>\n<p>前面提到了 YodaOS 选择拥抱 Node.js 和 Node.js 开发者，最大的一个原因就是在过去将近10年的时间，从最开始 Ryan Dahl 定义的，一个轻量级的 Web 服务器框架，到如今的 Express、Loopback、Koajs、Midway 和 Egg Framework，在 Web 服务器框架领域已经渐渐成熟。</p>\n<p>依托于 Node.js 提供的运行时，从 Grunt、Gulp 到现在的 Webpack 和 Parcel，在构建工具领域，社区也不断涌现出非常卓越的开源项目来。Node.js 正在发挥每位开发者的想象力，社区中几乎有你需要的一切，甚至于在社区中，有一句流传已久的名言：</p>\n<blockquote>\n<p>“any application that can be written in JavaScript, will eventually be written in JavaScript” ——Atwood’s Law</p>\n</blockquote>\n<p>意思就是说，只要能被 JavaScript 来编写的程序，终将使用 JavaScript 实现。那为什么不用 JavaScript 来写一个操作系统呢？</p>\n<p>当然上面的只是一个有趣的引子，Rokid 真正想做的是让 Node.js 开发者能够以更低的门槛进入语音交互和嵌入式领域。</p>\n<h3>Node.js 与 ShadowNode</h3>\n<p>YodaOS 虽然跟 Android 的架构相似，不过解决的问题，及目标设备并不尽然相同，对于现在越来越便宜的手机，Android 开发者几乎不用担心系统性能的问题。然而对于像智能音响、IoT 终端以及其他嵌入式设备，通常硬件资源都是非常紧缺的，在这种情况下，OS 就要解决开发者“既要节省资源、又要便于开发”的问题。</p>\n<p>于是针对中低端硬件产品（内存介于 128MB 到 256MB 之间），我们创造了 ShadowNode 来解决这个问题，它是 Rokid 基于三星 IoT.js 二次开发的一款 Node.js 运行时，它具备更快的启动速度和更低的资源占用，相比 IoT.js，它：</p>\n<ul>\n<li>提供了更好的错误栈信息和性能调试工具；</li>\n<li>支持了基于 N-API 的跨运行时模块执行；</li>\n<li>针对特定芯片的性能优化，比如 AmLogic A113 和 Kamino18；</li>\n</ul>\n<p>借助于 N-API 的 ABI 兼容特性，我们实现了 OS 上层框架和应用的运行时兼容性。比如开发者完全可以选择在更高级的设备上运行 YodaOS，此时内存和 Flash 不再是瓶颈，开发者只需要更换系统中的 Node.js 运行时，即可获得更快的执行速度，不需要修改一行上层代码。</p>\n<h3>最后</h3>\n<p>我们希望借助 YodaOS，为 Node.js 社区补全终端开发这一版图，让我们用这门亲切的语言，再次回到我们熟悉的“端”的开发。</p>\n<p>如果想一起加入 YodaOS，可以在 GitHub 上关注我们，项目地址：<a href=\"https://github.com/yodaos-project/yodaos\">https://github.com/yodaos-project/yodaos</a></p>\n</div>",
      "title": "YodaOS：一个属于 Node.js 社区的操作系统",
      "last_reply_at": "2019-02-10T13:29:48.032Z",
      "good": true,
      "top": false,
      "reply_count": 19,
      "visit_count": 1704,
      "create_at": "2019-01-29T07:25:20.180Z",
      "author": {
        "loginname": "yorkie",
        "avatar_url": "https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"
      }
    },
    {
      "id": "5b44291035342ab0690613d6",
      "author_id": "5b37500b5c8f1ea723a56b2b",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>Electron是一个跨平台的桌面应用开发框架，可以让我们用html css js的技术开发跨平台桌面上可以安装的软件。</p>\n<p><strong>前4讲免费试听地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ\">https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ</a></p>\n<p>electron Github的 star已经达到61957，那么他的<strong>用户量可能已经有100万了</strong>。还有大家知道的github的atom编辑器、微软的vscode编辑器，包括阿里内部的一些软件也是用 electron 开发的。既然这么热，<strong>那就一个字：学</strong>，大家都在学，你不学（有没有压力啊！！！）</p>\n<p><strong>28元购买地址</strong>:<a href=\"https://www.itying.com/goods-929.html\">https://www.itying.com/goods-929.html</a></p>\n<p><img src=\"//static.cnodejs.org/FqbpQ7iHRMdMdSrEGLD_xpe4CabH\" alt=\"1.png\"></p>\n</div>",
      "title": "Electron视频教程_Electron+Vue跨平台桌面软件开发视频教程（收费啊--不贵一包烟钱-有试听）",
      "last_reply_at": "2019-02-10T11:06:11.180Z",
      "good": false,
      "top": false,
      "reply_count": 31,
      "visit_count": 6970,
      "create_at": "2018-07-10T03:33:36.227Z",
      "author": {
        "loginname": "it-ionic",
        "avatar_url": "https://avatars1.githubusercontent.com/u/17946554?v=4&s=120"
      }
    },
    {
      "id": "5b852286632c7f422e5b81e5",
      "author_id": "5b85221808d0b0fb2d8e6c84",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近想用node.js重构公司后端。egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？</p>\n</div>",
      "title": "egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？",
      "last_reply_at": "2019-02-10T09:53:49.414Z",
      "good": false,
      "top": false,
      "reply_count": 57,
      "visit_count": 6178,
      "create_at": "2018-08-28T10:23:02.365Z",
      "author": {
        "loginname": "danielmlc",
        "avatar_url": "https://avatars2.githubusercontent.com/u/16604995?v=4&s=120"
      }
    },
    {
      "id": "5c4ebf61a4647e02328f1bba",
      "author_id": "5c4e697a3819b801aa5a1dde",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>请问下，有三个表，articles(文章), collections（专集）, articles_collection(关联表)\narticles和collections是多对多的关系，\n一个专集下可以收录多篇文章, 这时有两种状态(用articles_collection表中的status字段表示)\n1.收录中等待审核\n2.已收录</p>\n<p>三个表如下</p>\n<pre class=\"prettyprint\"><code>+-------------+--------------+----------------------------+\n|                        articles                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| title       | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n\n+-------------+--------------+----------------------------+\n|                        collections                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| title       | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n\n+-------------+--------------+----------------------------+\n|                        articles_collection                         |\n+-------------+--------------+----------------------------+\n| article_id          | int(11)      |                                   |\n| collection_id       | int(11)  |                            |\n| status       | int(11) |                            |\n+-------------+--------------+----------------------------+\n</code></pre><p>查询的场景为\n1.查某个专集下的文章, 包括收录中等待审核, 已收录\n2.查某个专集下的文章，只查已收录的</p>\n<p>请问下目前的设计是否合理呢? articles_collection表中索引怎么建合适呢？</p>\n</div>",
      "title": "mysql表、索引设计问题",
      "last_reply_at": "2019-02-10T09:37:56.548Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 630,
      "create_at": "2019-01-28T08:37:53.638Z",
      "author": {
        "loginname": "hujunyuan8058",
        "avatar_url": "https://avatars3.githubusercontent.com/u/37411247?v=4&s=120"
      }
    }
  ]
}